utarray: dynamic array macros for C structures
==============================================
Troy D. Hanson <thanson@users.sourceforge.net>
v1.9, March 2010

include::sflogo.txt[]
include::topnav_utarray.txt[]

Introduction
------------
include::toc.txt[]

A set of general-purpose dynamic array macros for C structures are included with
uthash in `utarray.h`.  To use these macros in your own C program, just
copy `utarray.h` into your source directory and use it in your programs.

  #include "utarray.h"

The dynamic array supports basic operations such as push, pop, and erase on the
array elements. These array elements can be any simple datatype or structure.
The array operations, based very loosely on the C++ STL vector methods, are
listed in full below.

Internally the dynamic array contains a contiguous memory region into which
the elements are copied. This buffer is grown as needed using `realloc` to
accomodate all the data that is pushed into it.

Download
~~~~~~~~
To download the `utarray.h` header file, follow the link on the
http://uthash.sourceforge.net[uthash home page]. 

BSD licensed
~~~~~~~~~~~~
This software is made available under the 
link:license.html[revised BSD license]. 
It is free and open source. 

Platforms
~~~~~~~~~
The 'utarray' macros have been tested on:

 * Linux, 
 * Mac OS X, 
 * Windows, using Visual Studio 2008 and Visual Studio 2010

Using utarray
------------

UT_array
~~~~~~~~
The array itself has the data type `UT_array`, regardless of the type of
elements to be stored in it. It is declared like,

  UT_array *a;

The examples below assume we've declared `UT_array *nums;` and `UT_array *strs;`.

Array elements
~~~~~~~~~~~~~~

Integers and strings
^^^^^^^^^^^^^^^^^^^^
Here are two examples of how we could now initialize arrays to store either
integers or strings,

  utarray_new(nums,&ut_int_icd);  /* to store integers */
  utarray_new(strs,&ut_str_icd);  /* to store strings */

Support for arrays of integers and strings uses these predefined `ut_int_icd`
and `ut_str_icd` helper structures. These will be covered in detail shortly.
For now, let's first see how to push data into the array. Here's how we could
push integers 0-9 into the `nums` array:

  int i;
  for(i=0; i < 10; i++) utarray_push_back(nums,&i);

Similarly, here's how we could push a couple of strings into the `strs` array:

  char *s;
  s = "hello"; utarray_push_back(strs, &s);
  s = "world"; utarray_push_back(strs, &s);

Note that the second argument is always a pointer to the type (so a literal
cannot be used). So in the case of strings, we are passing a `char**`.

Custom elements types
^^^^^^^^^^^^^^^^^^^^^
Of course, arrays can hold any type of element, not just integers and strings.
The elements can be basic types or structures. You need to define the C
functions to initialize an empty element, to copy an element and to destruct an
element. Any or all of these can be `NULL` to use default behavior explained
below. Finally, the size of the element must be provided so that the array can
be managed automatically. These C functions and the element size are passed
together as a `UT_icd` structure, defined in `utarray.h`:

  typedef struct {
      size_t sz;
      init_f *init;
      ctor_f *copy;
      dtor_f *dtor;
  } UT_icd;

The three function pointers `init`, `copy`, and `dtor` have these prototypes:

  typedef void (ctor_f)(void *dst, const void *src);
  typedef void (dtor_f)(void *elt);
  typedef void (init_f)(void *elt);

Here is when they are invoked:

[width="100%",cols="10^,90<",grid="none",options="none"]
|===============================================================================
| init  |  initialize an empty element as a result of `utarray_resize` or `utarray_extend_back`
| copy  |  copy an element due to an `utarray_push_back`, `utarray_inserta`, or `utarray_concat`
| dtor  |  destruct an element due to an `utarray_resize`, `utarray_pop_back`, `utarray_erase` or `utarray_clear`, `utarray_done` or `utarray_free`
|===============================================================================

Default behavior
++++++++++++++++
When `init`, `copy` or `dtor` are `NULL` they default to: memset-to-zero,
memcpy, and do-nothing, respectively.

For example, to have a utarray of `long` we'd declare a `UT_icd` with default
(`NULL`) values for `init`, `copy` or `dtor`:

  UT_icd long_icd = {sizeof(long), NULL, NULL, NULL };
  utarray_new(nums, &long_icd);

Looking at the four members of `long_icd`, we have:
 - the element size first,
 - then the initializor function (here `NULL` which zero fills new elements using memset),
 - then the copy function (here `NULL` which simply does a `memcpy`), and
 - the destructor function (here `NULL`, which means no cleanup is needed)

For another example, if you had a structure of `int` pairs called `intpair_t`
as shown below, you could make a utarray of them using,

  typedef struct {
    int a;
    int b;
  } intpair_t;

  UT_icd intpair_icd = {sizeof(intpair_t), NULL, NULL, NULL};
  UT_array *pairs;
  utarray_new(pairs,&intpair_icd);

Non-default behavior
++++++++++++++++++++
Now let's take an example where we use non- `NULL` values in the `UT_icd`.
Suppose we plan to make a utarray of this structure,

  typedef struct {
    int a;
    char *s;
  } intchar_t;

We'll need to "deep copy" and "deep free" the members of this structure so that
`s` does not leak when its enclosing structure is freed., and so that `s` is
copied, rather than shared, whenever the enclosing structure is copied.

  void intchar_copy(void *_dst, void *_src) {
    intchar_t *dst = (intchar_t*)_dst, *src = (intchar_t*)_src;
    dst->a = src->a;
    dst->s = src->s ? strdup(src->s) : NULL;
  }
  void intchar_dtor(void *_elt) {
    intchar_t *elt = (intchar_t*)_elt;
    free(dst->s);
  }

Notice in this case that we can use the default `init` function (memset to
zero).

  UT_icd intchar_icd = {sizeof(intchar_t), NULL, intchar_copy, intchar_dtor};
  UT_array *intchars;
  utarray_new(intchars, &intchar_icd);

We'll see how the `init`, `copy` and `dtor` functions get used below.

Array operations
~~~~~~~~~~~~~~~~

[width="100%",cols="30<m,70<",grid="none",options="none"]
|===============================================================================
| utarray_new(a,icd)         |
| utarray_free(a)            |
| utarray_init(a,icd)        |
| utarray_done(a)            |
| utarray_reserve(a,by)      |
| utarray_push_back(a,p)     |
| utarray_pop_back(a)        |
| utarray_extend_back(a)     |
| utarray_len(a)             |
| utarray_eltptr(a,j)        |
| utarray_eltidx(a,e)        |
| utarray_insert(a,p,j)      |
| utarray_inserta(a,w,j)     |
| utarray_resize(dst,num)    |
| utarray_concat(dst,src)    |
| utarray_erase(a,pos,len)   |
| utarray_clear(a)           |
| utarray_sort(a,cmp)        |
| utarray_front(a)           |
| utarray_next(a,e)          |
| utarray_back(a)            |
|===============================================================================


You can use any structure with these macros, as long as the structure 
contains a `next` pointer. If you want to make a doubly-linked list, 
the element also needs to have a `prev` pointer.

  typedef struct {
      char *name;
      struct element *prev; /* needed for a doubly-linked list only */
      struct element *next; /* needed for singly- or doubly-linked lists */
  } element;

You can name your structure anything. In the example above it is called `element`.
Within a particular list, all elements must be of the same type. 

List operations
~~~~~~~~~~~~~~~
The lists support inserting or deleting elements, sorting the elements and 
iterating over them.

[width="100%",cols="10<m,10<m,10<m",grid="cols",options="header"]
|===============================================================================
|Singly-linked             | Doubly-linked              | Circular, doubly-linked
|LL_PREPEND(head,add);     | DL_PREPEND(head,add);      | CDL_PREPEND(head,add;
|LL_APPEND(head,add);      | DL_APPEND(head,add);       | 
|LL_DELETE(head,del);      | DL_DELETE(head,del);       | CDL_DELETE(head,del);
|LL_SORT(head,cmp);        | DL_SORT(head,cmp);         | CDL_SORT(head,cmp);
|LL_FOREACH(head,elt) {...}| DL_FOREACH(head,elt) {...} | CDL_FOREACH(head,elt) {...}
|LL_FOREACH_SAFE(head,elt,tmp) {...}| DL_FOREACH_SAFE(head,elt,tmp) {...} | CDL_FOREACH_SAFE(head,elt,tmp1,tmp2) {...}
|LL_SEARCH_SCALAR(head,elt,mbr,val);| DL_SEARCH_SCALAR(head,elt,mbr,val); | CDL_SEARCH_SCALAR(head,elt,mbr,val);
|LL_SEARCH(head,elt,like,cmp);| DL_SEARCH(head,elt,like,cmp); | CDL_SEARCH(head,elt,like,cmp);
|===============================================================================

'Prepend' means to insert an element in front of the existing list head (if any),
changing the list head to the new element. 'Append' means to add an element at the
end of the list, so it becomes the new tail element.  

The 'sort' operation never moves the elements in memory; rather it only adjusts
the list order by altering the `prev` and `next` pointers in each element. Also
the sort operation can change the list head to point to a new element.

The 'foreach' operation is for easy iteration over the list from the head to the
tail. A usage example is shown below. You can of course just use the `prev` and
`next` pointers directly instead of using the 'foreach' macros.
The 'foreach_safe' operation should be used if you plan to delete any of the list
elements while iterating. 

The 'search' operation is a shortcut for iteration in search of a particular
element. It is not any faster than manually iterating and testing each element.
There are two forms: the "scalar" version searches for an element using a
simple equality test on a given structure member, while the general version takes an
element to which all others in the list will be compared using a `cmp` function.


The parameters shown in the table above are explained here:

head::
  The list head (a pointer to your list element structure).
add::
  A pointer to the list element structure you are adding to the list.
del::
  A pointer to the list element structure you are deleting from the list.
elt::
  A pointer that will be assigned to each list element in succession (see
  example) in the case of iteration macros; also, the output pointer from
  the search macros.
like::
  An element pointer, having the same type as `elt`, for which the search macro 
  seeks a match (if found, the match is stored in `elt`). A match is determined
  by the given `cmp` function.
cmp::
  pointer to comparison function which accepts two arguments-- these are
  pointers to two element structures to be compared. The comparison function
  must return an `int` that is negative, zero, or positive, which specifies
  whether the first item should sort before, equal to, or after the second item,
  respectively. (In other words, the same convention that is used by `strcmp`).
  Note that under Visual Studio 2008 you may need to declare the two arguments
  as `void *` and then cast them back to their actual types.
tmp::
  A pointer of the same type as `elt`. Used internally. Need not be initialized.
mbr::
  In the scalar search macro, the name of a member within the `elt` structure which
  will be tested (using `==`) for equality with the value `val`.
val::
  In the scalar search macro, specifies the value of (of structure member
  `field`) of the element being sought.

Example
~~~~~~~
This example program reads names from a text file (one name per line), and
appends each name to a doubly-linked list. Then it sorts and prints them.

.A doubly-linked list
--------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "utlist.h"

#define BUFLEN 20

typedef struct el {
    char bname[BUFLEN];
    struct el *next, *prev;
} el;

int namecmp(el *a, el *b) {
    return strcmp(a->bname,b->bname);
}

el *head = NULL; /* important- initialize to NULL! */

int main(int argc, char *argv[]) {
    el *name, *elt, *tmp, etmp;

    char linebuf[BUFLEN];
    FILE *file;

    if ( (file = fopen( "test11.dat", "r" )) == NULL ) {
        perror("can't open: "); 
        exit(-1);
    }

    while (fgets(linebuf,BUFLEN,file) != NULL) {
        if ( (name = (el*)malloc(sizeof(el))) == NULL) exit(-1);
        strncpy(name->bname,linebuf,BUFLEN);
        DL_APPEND(head, name);
    }
    DL_SORT(head, namecmp);
    DL_FOREACH(head,elt) printf("%s", elt->bname);

    memcpy(&etmp.bname, "WES\n", 5);
    DL_SEARCH(head,elt,&etmp,namecmp);
    if (elt) printf("found %s\n", elt->bname);

    /* now delete each element, use the safe iterator */
    DL_FOREACH_SAFE(head,elt,tmp) {
      DL_DELETE(head,elt);
    }

    fclose(file);

    return 0;
}
--------------------------------------------------------------------------------

// vim: set nowrap syntax=asciidoc: 

