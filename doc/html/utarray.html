<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.5.0" />
<title>utarray: dynamic array macros for C structures</title>
<link rel="stylesheet" href="./tdh.css" type="text/css" />
<link rel="stylesheet" href="./tdh-quirks.css" type="text/css" />
</head>
<body>
<div id="header">
<h1>utarray: dynamic array macros for C structures</h1>
<span id="author">Troy D. Hanson</span><br />
<span id="email"><tt>&lt;<a href="mailto:thanson@users.sourceforge.net">thanson@users.sourceforge.net</a>&gt;</tt></span><br />
<span id="revnumber">version 1.9,</span>
<span id="revdate">March 2010</span>
</div>
<div id="preamble">
<div class="sectionbody">
<a style="float: right; padding-right: 50px" href="http://sourceforge.net/projects/uthash"><img style="border: 0" src="http://sflogo.sourceforge.net/sflogo.php?group_id=163879&amp;type=13" width="120" height="30" alt="uthash at SourceForge.net" /></a>
  <div id="topnav" style="font-size: 9pt; font-family: sans-serif;">
  <a style="padding: 8px;" href="index.html">uthash home</a>
  >>  utarray macros
  </div>
</div>
</div>
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div id="toc"></div>
<script>
window.onload=generate_TOC

/* Author: Mihai Bazon, September 2002
 * <a href="http://students.infoiasi.ro/~mishoo">http://students.infoiasi.ro/~mishoo</a>
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */

function H_getText(el) {
  var text = "";
  for (var i = el.firstChild; i != null; i = i.nextSibling) {
    if (i.nodeType == 3 /* Node.TEXT_NODE, IE doesn't speak constants */)
      text += i.data;
    else if (i.firstChild != null)
      text += H_getText(i);
  }
  return text;
}

function TOC_EL(el, text, level) {
  this.element = el;
  this.text = text;
  this.level = level;
}

function getHeadlines(el) {
  var l = new Array;
  var rx = /[hH]([2-3])/;
  // internal recursive function that scans the DOM tree
  var rec = function (el) {
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
        if (rx.exec(i.tagName))
          l[l.length] = new TOC_EL(i, H_getText(i), parseInt(RegExp.$1));
        rec(i);
      }
    }
  }
  rec(el);
  return l;
}

function generate_TOC() {
  var parent = document.getElementById("toc");
  var toc_hdr = document.createElement("div");
  var toc_hdr_txt = document.createTextNode("CONTENTS");
  toc_hdr.appendChild(toc_hdr_txt);
  /* toc_hdr.setAttribute("id","hdr"); */
  toc_hdr.id = "hdr";
  parent.appendChild(toc_hdr);
  var hs = getHeadlines(document.getElementsByTagName("body")[0]);
  for (var i = 0; i < hs.length; ++i) {
    var hi = hs[i];
    var d = document.createElement("div");
    if (hi.element.id == "") hi.element.id = "gen" + i;
    var a = document.createElement("a");
    a.href = "#" + hi.element.id;
    a.appendChild(document.createTextNode(hi.text));
    d.appendChild(a);
    d.className = "level" + hi.level;
    parent.appendChild(d);
    /*
    if (hi.level == 3) {
        var dvtop = document.createElement("div");
        dvtop.className = "toplink";
        dvtop.appendChild(document.createTextNode("^top^"));
        dvtop.onclick=function(){scrollTo(0,0);};
        hi.element.appendChild(dvtop);
    }
    */
  }
}
</script>
<div class="paragraph"><p>A set of general-purpose dynamic array macros for C structures are included with
uthash in <tt>utarray.h</tt>.  To use these macros in your own C program, just
copy <tt>utarray.h</tt> into your source directory and use it in your programs.</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>#include "utarray.h"</tt></pre>
</div></div>
<div class="paragraph"><p>The dynamic array supports basic operations such as push, pop, and erase on the
array elements. These array elements can be any simple datatype or structure.
The array operations, based very loosely on the C++ STL vector methods, are
listed in full below.</p></div>
<div class="paragraph"><p>Internally the dynamic array contains a contiguous memory region into which
the elements are copied. This buffer is grown as needed using <tt>realloc</tt> to
accomodate all the data that is pushed into it.</p></div>
<h3 id="_download">Download</h3><div style="clear:left"></div>
<div class="paragraph"><p>To download the <tt>utarray.h</tt> header file, follow the link on the
<a href="http://uthash.sourceforge.net">uthash home page</a>.</p></div>
<h3 id="_bsd_licensed">BSD licensed</h3><div style="clear:left"></div>
<div class="paragraph"><p>This software is made available under the
<a href="license.html">revised BSD license</a>.
It is free and open source.</p></div>
<h3 id="_platforms">Platforms</h3><div style="clear:left"></div>
<div class="paragraph"><p>The <em>utarray</em> macros have been tested on:</p></div>
<div class="ulist"><ul>
<li>
<p>
Linux,
</p>
</li>
<li>
<p>
Mac OS X,
</p>
</li>
<li>
<p>
Windows, using Visual Studio 2008 and Visual Studio 2010
</p>
</li>
</ul></div>
</div>
<h2 id="_using_utarray">Using utarray</h2>
<div class="sectionbody">
<h3 id="_ut_array">UT_array</h3><div style="clear:left"></div>
<div class="paragraph"><p>The array itself has the data type <tt>UT_array</tt>, regardless of the type of
elements to be stored in it. It is declared like,</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>UT_array *a;</tt></pre>
</div></div>
<div class="paragraph"><p>The examples below assume we&#8217;ve declared <tt>UT_array *nums;</tt> and <tt>UT_array *strs;</tt>.</p></div>
<h3 id="_array_elements">Array elements</h3><div style="clear:left"></div>
<h4 id="_integers_and_strings">Integers and strings</h4>
<div class="paragraph"><p>Here are two examples of how we could now initialize arrays to store either
integers or strings,</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>utarray_new(nums,&amp;ut_int_icd);  /* to store integers */
utarray_new(strs,&amp;ut_str_icd);  /* to store strings */</tt></pre>
</div></div>
<div class="paragraph"><p>Support for arrays of integers and strings uses these predefined <tt>ut_int_icd</tt>
and <tt>ut_str_icd</tt> helper structures. These will be covered in detail shortly.
For now, let&#8217;s first see how to push data into the array. Here&#8217;s how we could
push integers 0-9 into the <tt>nums</tt> array:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>int i;
for(i=0; i &lt; 10; i++) utarray_push_back(nums,&amp;i);</tt></pre>
</div></div>
<div class="paragraph"><p>Similarly, here&#8217;s how we could push a couple of strings into the <tt>strs</tt> array:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>char *s;
s = "hello"; utarray_push_back(strs, &amp;s);
s = "world"; utarray_push_back(strs, &amp;s);</tt></pre>
</div></div>
<div class="paragraph"><p>Note that the second argument is always a pointer to the type (so a literal
cannot be used). So in the case of strings, we are passing a <tt>char**</tt>.</p></div>
<h4 id="_custom_elements_types">Custom elements types</h4>
<div class="paragraph"><p>Of course, arrays can hold any type of element, not just integers and strings.
The elements can be basic types or structures. You need to define the C
functions to initialize an empty element, to copy an element and to destruct an
element. Any or all of these can be <tt>NULL</tt> to use default behavior explained
below. Finally, the size of the element must be provided so that the array can
be managed automatically. These C functions and the element size are passed
together as a <tt>UT_icd</tt> structure, defined in <tt>utarray.h</tt>:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>typedef struct {
    size_t sz;
    init_f *init;
    ctor_f *copy;
    dtor_f *dtor;
} UT_icd;</tt></pre>
</div></div>
<div class="paragraph"><p>The three function pointers <tt>init</tt>, <tt>copy</tt>, and <tt>dtor</tt> have these prototypes:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>typedef void (ctor_f)(void *dst, const void *src);
typedef void (dtor_f)(void *elt);
typedef void (init_f)(void *elt);</tt></pre>
</div></div>
<div class="paragraph"><p>Here is when they are invoked:</p></div>
<div class="tableblock">
<table rules="none"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="10%" />
<col width="90%" />
<tbody>
<tr>
<td align="center" valign="top"><p class="table">init</p></td>
<td align="left" valign="top"><p class="table">initialize an empty element as a result of <tt>utarray_resize</tt> or <tt>utarray_extend_back</tt></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">copy</p></td>
<td align="left" valign="top"><p class="table">copy an element due to an <tt>utarray_push_back</tt>, <tt>utarray_inserta</tt>, or <tt>utarray_concat</tt></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">dtor</p></td>
<td align="left" valign="top"><p class="table">destruct an element due to an <tt>utarray_resize</tt>, <tt>utarray_pop_back</tt>, <tt>utarray_erase</tt> or <tt>utarray_clear</tt>, <tt>utarray_done</tt> or <tt>utarray_free</tt></p></td>
</tr>
</tbody>
</table>
</div>
<h5 id="_simple_elements">Simple elements</h5>
<div class="paragraph"><p>When <tt>init</tt>, <tt>copy</tt> or <tt>dtor</tt> are <tt>NULL</tt> they default to: memset-to-zero,
memcpy, and do-nothing, respectively.</p></div>
<div class="paragraph"><p>For example, to have a utarray of <tt>long</tt> we&#8217;d declare a <tt>UT_icd</tt> with default
(<tt>NULL</tt>) values for <tt>init</tt>, <tt>copy</tt> or <tt>dtor</tt>:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>UT_icd long_icd = {sizeof(long), NULL, NULL, NULL };
utarray_new(nums, &amp;long_icd);</tt></pre>
</div></div>
<div class="paragraph"><p>Looking at the four members of <tt>long_icd</tt>, we have:
 - the element size first,
 - then the initializor function (here <tt>NULL</tt> which zero fills new elements using memset),
 - then the copy function (here <tt>NULL</tt> which simply does a <tt>memcpy</tt>), and
 - the destructor function (here <tt>NULL</tt>, which means no cleanup is needed)</p></div>
<div class="paragraph"><p>For another example, if you had a structure of <tt>int</tt> pairs called <tt>intpair_t</tt>
as shown below, you could make a utarray of them using,</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>typedef struct {
  int a;
  int b;
} intpair_t;</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>UT_icd intpair_icd = {sizeof(intpair_t), NULL, NULL, NULL};
UT_array *pairs;
utarray_new(pairs,&amp;intpair_icd);</tt></pre>
</div></div>
<h5 id="_complex_elements">Complex elements</h5>
<div class="paragraph"><p>When elements contain pointers that require more complex initialization, copy,
or destruct procedures, we use non- <tt>NULL</tt> values in the <tt>UT_icd</tt>.  Suppose we
plan to make a utarray of this element:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>typedef struct {
  int a;
  char *s;
} intchar_t;</tt></pre>
</div></div>
<div class="paragraph"><p>We&#8217;ll need to provide code to "deep copy" and "deep free" the <tt>char *s</tt> so
it doesn&#8217;t leak when the enclosing element is freed, and so that it is
copied, rather than shared, whenever the enclosing element is copied.</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>void intchar_copy(void *_dst, void *_src) {
  intchar_t *dst = (intchar_t*)_dst, *src = (intchar_t*)_src;
  dst-&gt;a = src-&gt;a;
  dst-&gt;s = src-&gt;s ? strdup(src-&gt;s) : NULL;
}
void intchar_dtor(void *_elt) {
  intchar_t *elt = (intchar_t*)_elt;
  if (dst-&gt;s) free(dst-&gt;s);
}</tt></pre>
</div></div>
<div class="paragraph"><p>We still use the default <tt>init</tt> function (memset to zero) since that is sufficient here:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>UT_icd intchar_icd = {sizeof(intchar_t), NULL, intchar_copy, intchar_dtor};
UT_array *intchars;
utarray_new(intchars, &amp;intchar_icd);</tt></pre>
</div></div>
<div class="paragraph"><p>We&#8217;ll see how the <tt>init</tt>, <tt>copy</tt> and <tt>dtor</tt> functions get used below.</p></div>
<h3 id="_array_operations">Array operations</h3><div style="clear:left"></div>
<div class="tableblock">
<table rules="none"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="55%" />
<col width="44%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_new(UT_array *a, UT_icd *icd)</tt></p></td>
<td align="left" valign="top"><p class="table">allocate a new array</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_free(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">free an allocated array</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_init(UT_array *a,UT_icd *icd)</tt></p></td>
<td align="left" valign="top"><p class="table">init an array (non-alloc)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_done(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">dispose of an array (non-allocd)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_reserve(UT_array *a,int n)</tt></p></td>
<td align="left" valign="top"><p class="table">ensure space available for <em>n</em> more elements</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_push_back(UT_array *a,void *p)</tt></p></td>
<td align="left" valign="top"><p class="table">push element p onto a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_pop_back(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">pop last element from a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_extend_back(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">push empty element onto a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_len(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">get length of a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_eltptr(UT_array *a,int j)</tt></p></td>
<td align="left" valign="top"><p class="table">get pointer of element from index</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_eltidx(UT_array *a,void *e)</tt></p></td>
<td align="left" valign="top"><p class="table">get index of element from pointer</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_insert(UT_array *a,void *p, int j)</tt></p></td>
<td align="left" valign="top"><p class="table">insert element p to index j</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_inserta(UT_array *a,UT_array *w, int j)</tt></p></td>
<td align="left" valign="top"><p class="table">insert array w into array a at index j</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_resize(UT_array *dst,int num)</tt></p></td>
<td align="left" valign="top"><p class="table">extend or shrink array to num elements</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_concat(UT_array *dst,UT_array *src)</tt></p></td>
<td align="left" valign="top"><p class="table">copy src to end of dst array</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_erase(UT_array *a,int pos,int len)</tt></p></td>
<td align="left" valign="top"><p class="table">remove len elements from a[pos]..a[pos+len-1]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_clear(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">clear all elements from a ,setting its length to zero</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_sort(UT_array *a,cmpfcn *cmp)</tt></p></td>
<td align="left" valign="top"><p class="table">sort elements of a using comparison function</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_front(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">get first element of a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_next(UT_array *a,void *e)</tt></p></td>
<td align="left" valign="top"><p class="table">get element of a following e (first element if null)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><tt>utarray_back(UT_array *a)</tt></p></td>
<td align="left" valign="top"><p class="table">get last element of a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Notes
1. <tt>utarray_new</tt> and <tt>utarray_free</tt> are used to allocate a new array and free it,
   while <tt>utarray_init</tt> and <tt>utarray_done</tt> can be used if the UT_array is already
   allocated and just needs to be initialized (or internally freed)
2. <tt>utarray_reserve</tt> takes the "delta" of elements to reserve (not the total
   desired capacity of the array; this differs from the C++ STL vector usage)
3. <tt>utarray_sort</tt> expects a comparison function having the usual <tt>strcmp</tt> -like
   convention where it accepts two elements (a and b) and returns a negative
   value if a precedes b, 0 if a and b sort equally, and positive if b precedes a.
   This is an example of a comparison function:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>int intsort(const void *a,const void*b) {
    int _a = *(int*)a;
    int _b = *(int*)b;
    return _a - _b;
}</tt></pre>
</div></div>
<h3 id="_samples">Samples</h3><div style="clear:left"></div>
<div class="listingblock">
<div class="title">Integer array</div>
<div class="content">
<pre><tt></tt></pre>
</div></div>
<div class="listingblock">
<div class="title">String array</div>
<div class="content">
<pre><tt></tt></pre>
</div></div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.9<br />
Last updated 2010-03-28 20:48:40 PDT
</div>
</div>
</body>
</html>
